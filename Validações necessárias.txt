| Validação                                               | Exemplo de erro                   | O que fazer                    |
| ------------------------------------------------------- | --------------------------------- | ------------------------------ |
| 1. Argumentos são números válidos                       | `"1" "2" "a"`                     | printar `Error` e sair         |
| 2. Não há **números duplicados**                        | `"2" "1" "2"`                     | `Error` e sair                 |
| 3. Cabe dentro de um **int 32 bits**                    | `"2147483648"` ou `"-2147483649"` | `Error` e sair                 |
| 4. Não há argumentos vazios ou espaços soltos           | `"   "`                           | `Error` e sair                 |
| 5. Pode lidar com múltiplos números num único argumento | `"1 2 3"`                         | precisa separar com `ft_split` |


bool	parse_args(t_dlist *stack_a, int argc, char **argv)
{
	char	**split;
	int		i;
	int		j = 0;
	long	num;

	while (++j < argc)
	{
		split = ft_split(argv[j], ' ');
		if (!split)
			return (false);
		i = 0;
		while (split[i])
		{
			if (!ft_valid_number(split[i]))
				return (free_split(split), false);
			num = ft_atol(split[i]);
			if (num < INT_MIN || num > INT_MAX)
				return (free_split(split), false);
			if (has_duplicate(stack_a, (int)num))
				return (free_split(split), false);
			fill_stack(stack_a, (int)num);
			i++;
		}
		free_split(split);
	}
	return (true);
}

#include "push_swap.h"

static bool	ft_validations(t_dlist *stack_a, char *str);
static bool	ft_process_split(t_dlist *stack_a, char **split);

bool	parse_and_fill(t_dlist *stack_a, int argc, char **argv)
{
	char	**split;
	int		j;

	j = 0;
	while (++j < argc)
	{
		split = ft_split(argv[j], ' ');
		if (!split)
			return (false);
		if (!ft_process_split(stack_a, split))
		{
			ft_free_split(split);
			return (false);
		}
		ft_free_split(split);
	}
	return (true);
}


static bool	ft_process_args(t_dlist *stack_a, char **split)
{
	long	num;
	int		i;

	i = 0;
	while (split[i])
	{
		if (!ft_valid_number(split[i]))
			return (false);
		num = ft_atol(split[i]);
		if (num < INT_MIN || num > INT_MAX)
			return (false);
		if (has_duplicate(stack_a, (int)num))
			return (false);
		fill_stack(stack_a, (int)num);
		i++;
	}
	return (true);
}

